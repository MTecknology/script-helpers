#!/bin/sh
##
# Title:      Script Helpers (sh)
# Copyright:  2020 Michael Lustfield <MTecknology>
# License:    GPL-3+
##


##
# Convenience Variables
##

# Version of this script
SCRIPT_HELPER_VERSION='dev'
readonly SCRIPT_HELPER_VERSION
export SCRIPT_HELPER_VERSION

# Log Levels
DEBUG=0; D=0
INFO=1; I=1
WARN=2; W=2
ERROR=3; E=3
readonly DEBUG D INFO I WARN W ERROR E
export DEBUG D INFO I WARN W ERROR E


##
# Helper Functions
##


##
# Return true if script version is between min/max ('dev' == git_HEAD).
#
# **Usage:** helper_version min [max]
#
# - min: minimum supported version
# - max: maximum supported version
#
# **Returns:** true if script version is between min and [optionally:max]
##
helper_version() {
	# Check minimum version
	if [ "$SCRIPT_HELPER_VERSION" != 'dev' ]; then
		version_compare "$SCRIPT_HELPER_VERSION" 'lesser_than' "$1" && return 1
	fi

	# Check maximum version
	[ "${2:-dev}" = 'dev' ] && return 0
	version_compare "$SCRIPT_HELPER_VERSION" 'greater_than' "$2" && return 1

	return 0
}


##
# Print a formatted (critical) message and exit with status.
#
# **Usage:** die [exit_status] message
#
# - exit_status: exit code to use with script termination (default: 1)
# - message: message to print before terminating script execution
##
die() {
        # If first argument was an integer, use as exit_status
        if [ "$1" -eq "$1" ] 2>/dev/null; then
                _exit_status="$1"; shift
        else
                _exit_status=1
        fi

        printf '*** CRITICAL: %s ***\n' "$1"
        exit "$_exit_status"
}


##
# Manage a lock file.
#
# **Usage:** lock operation [key]
#
# - operation: acquire, destroy
# - key: any unique value to identify this script (default: $0)
#
# **Returns:** true if success
##
lock() {
	_h="$(printf '%s' "${2:-$0}" | cksum | awk '{print $1}')"
	case "$1" in
		acquire) _lock_acquire "/tmp/$_h.lock";;
		destroy) rm -f "/tmp/$_h.lock";;
	esac
}

# Create a lock file and populate it with PID.
_lock_acquire() {
	# Check if running
	[ -e "$1" ] && kill -0 "$(cat "$1")" && return 1

	# make sure the lockfile is removed when we exit and then claim it
	# shellcheck disable=SC2064 #[we want this expanding now]
	trap "rm -f '$1'; exit" INT TERM EXIT
	echo $$ > "$1"

	return 0
}


##
# Print a formatted message if ENV[LOG_LEVEL] >= level.
#
# **Usage:** log level message
#
# - level: 0:debug, 1:info, \*2:warn, 3:error
# - message: any string of text to be sent to stdout
#
# **Defaults:**
#
# - ENV[LOG_LEVEL]: 2
#
##
log() {
        if [ "${LOG_LEVEL:-2}" -le "$1" ]; then
                case "$1" in
                        0) _lvl='DEBUG';;
                        1) _lvl='INFO';;
                        2) _lvl='WARN';;
                        3) _lvl='ERROR';;
                        *) _lvl='UNKNOWN';;
                esac

                printf '*** %s: %s ***\n' "$_lvl" "$2"
        fi
}


##
# Run all detection routines.
#
# **Usage:** detect_all
#
# **Returns:** true if all detections succeed
##
detect_all() {
	grep '^detect_.+\(\)\s\{' "$0" |
	  while read -r _line; do
		eval "${_line%%(*}" || return 1
	done

	return 0
}


##
# Detect kernel of running system.
#
# **Usage:** detect_kernel
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_KERNEL
##
detect_kernel() {
	if command -v uname >/dev/null; then
		_kern_uname
		[ -n "$H_KERNEL" ] && return 0
	fi

	return 1
}

# Use uname output to detect kernel.
_kern_uname() {
	H_KERNEL="$(uname --kernel-name)"
	export H_KERNEL
}


##
# Detect distribution of running system.
#
# **Usage:** detect_distro
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_DISTRO
##
detect_distro() {
	if [ -n "$H_KERNEL" ]; then
		_kern="$H_KERNEL"
	else
		_kern="$(detect_kernel; printf '%s' "$H_KERNEL")"
	fi

	if command -v lsb_release >/dev/null; then
		_distro_lsb
		[ -n "$H_DISTRO" ] && return 0
	fi;if [ "$_kern" = 'FreeBSD' ]; then
		_distro_freebsd
		[ -n "$H_DISTRO" ] && return 0
	fi

	return 1
}

# Detect release of Linux systems
_distro_lsb() {
	H_DISTRO="$(lsb_release --short --id)"
	export H_DISTRO
}

# Detect release of FreeBSD systems
_distro_freebsd() {
	H_DISTRO='FreeBSD'
	export H_DISTRO
}


##
# Detect distro release of running system.
#
# **Usage:** detect_release
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_RELEASE
##
detect_release() {
	if command -v lsb_release >/dev/null; then
		_release_lsb
		[ -n "$H_RELEASE" ] && return 0
	fi;if command -v freebsd-version >/dev/null; then
		_release_freebsd
		[ -n "$H_RELEASE" ] && return 0
	fi

	return 1
}

# Detect release version using lsb_release
_release_lsb() {
	H_RELEASE="$(lsb_release --short --release)"
	export H_RELEASE
}

# Detect release of FreeBSD system
_release_freebsd() {
	H_RELEASE="$(freebsd-version -k)"
	export H_RELEASE
}


##
# Evaluate if running kernel matches provided argument(s).
#
# **Usage:** is_kernel match [match..]
#
# - match: any string to test against (Linux, BSD, etc.)
#
# **Returns:** true if running kernel matches a provided 'match'
##
is_kernel() {
	if [ -n "$H_KERNEL" ]; then
		_needle="$H_KERNEL"
	else
		_needle="$(detect_kernel; printf '%s' "$H_KERNEL")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect kernel.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if running distribution matches provided argument(s).
#
# **Usage:** is_distro match [match..]
#
# - match: any string to test against (Debian, Ubuntu, RHEL, etc.)
#
# **Returns:** true if running distro matches a provided 'match'
##
is_distro() {
	if [ -n "$H_DISTRO" ]; then
		_needle="$H_DISTRO"
	else
		_needle="$(detect_distro; printf '%s' "$H_DISTRO")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect distro.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if running distro release matches provided argument.
#
# **Usage:** is_release match [match..]
#
# - match: any string to test against (12.04, 10.1, etc.)
#
# **Returns:** true if running release matches a provided 'match'
##
is_release() {
	if [ -n "$H_RELEASE" ]; then
		_needle="$H_RELEASE"
	else
		_needle="$(detect_release; printf '%s' "$H_RELEASE")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect release.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_true str
#
# - str: any string to test against
#
# **Returns:** true if ($str is 0) or (lower($str) == true)
##
is_true() {
        _str="$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')"
        [ "$_str" -eq '0' ] 2>/dev/null && return 0
        [ "$_str" = 'true' ] && return 0

        return 1
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_false str
#
# - str: any string to test against
#
# **Returns:** true if ($str != 0) or (lower($str) != true)
##
is_false() {
        is_true "$1" && return 1
        return 0
}


##
# Compare two versions.
#
# **Usage:** version_compare ver1 operator ver2
#
# - operator: [-lt, lesser_than, -gt, greater_than, -eq, equal, -ne, not_equal]
# - ver{1,2}: arbitrary version strings to compare
#
# **Returns:** true if comparison statement is correct
##
version_compare() {
	case "$2" in
		# Note: awk is wak... inverse operations so false=non-zero
		lesser_than|-lt) _op='>';;
		lesser_or_equal|-le) _op='<=';;
		greater_than|-gt) _op='<';;
		greater_or_equal|-ge) _op='<=';;
		equal|-eq) _op='!=';;
		not_equal|-ne) _op='==';;
		*) die 7 'Unknown operatoration called for version_compare().';;
	esac

	# shellcheck disable=SC2086 #[false-positive: nested quotes]
	return "$(awk 'BEGIN {print("'$1'" '$_op' "'$3'")}')"
}

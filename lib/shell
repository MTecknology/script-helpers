#!/bin/sh
##
# Title:      Script Helpers (sh)
# Copyright:  2020 Michael Lustfield <MTecknology>
# License:    GPL-3+
##


##
# Convenience Variables
##

SCRIPT_HELPER_VERSION='dev'
# Version of this script
readonly SCRIPT_HELPER_VERSION
export SCRIPT_HELPER_VERSION

DEBUG=0; D=0
INFO=1; I=1
WARN=2; W=2
ERROR=3; E=3
# Log Levels
readonly D DEBUG I INFO W WARN E ERROR
export D DEBUG I INFO W WARN E ERROR


##
# Helper Functions
##


##
# Return true if script version is between min/max ('dev' == git_HEAD).
#
# **Usage:** helper_version min [max]
#
# **Returns:** true if script version is between min and [optionally:max]
##
helper_version() {
	# Check minimum version
	if [ "$SCRIPT_HELPER_VERSION" != 'dev' ]; then
		version_compare "$SCRIPT_HELPER_VERSION" 'lesser_than' "$1" && return 1
	fi

	# Check maximum version
	[ "${2:-dev}" = 'dev' ] && return 0
	version_compare "$SCRIPT_HELPER_VERSION" 'greater_than' "$2" && return 1

	return 0
}


##
# Print a formatted (critical) message and exit with status.
#
# **Usage:** die [exit_status] message
#
# **Defaults:**
#
# - exit_status: 1
##
die() {
        # If first argument was an integer, use as exit_status
        if [ "$1" -eq "$1" ] 2>/dev/null; then
                _exit_status="$1"; shift
        else
                _exit_status=1
        fi

        printf '*** CRITICAL: %s ***\n' "$1"
        exit "$_exit_status"
}


##
# Print a formatted (critical) message if ENV[LOG_LEVEL] >= level.
#
# **Usage:** log level message
#
# **Defaults:**
#
# - ENV[LOG_LEVEL]: 2
#
# **Parameter Options:**
#
# - level => 0:debug, 1:info, \*2:warn, 3:error
##
log() {
        if [ "${LOG_LEVEL:-2}" -le "$1" ]; then
                case "$1" in
                        0) lvl='DEBUG';;
                        1) lvl='INFO';;
                        2) lvl='WARN';;
                        3) lvl='ERROR';;
                        *) lvl='UNKNOWN';;
                esac

                printf '*** %s: %s ***\n' "$lvl" "$2"
        fi
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_true "$str"
#
# **Returns:** '0' if ($str is 0) or (lower($1) == true)
##
is_true() {
        str="$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')"
        [ "$str" -eq '0' ] 2>/dev/null && return 0
        [ "$str" = 'true' ] && return 0

        return 1
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_false "$str"
#
# **Returns:** '0' if ($str is 1) or (lower($1) != true)
##
is_false() {
        is_true "$1" && return 1
        return 0
}


##
# Compare two versions.
#
# **Usage:** ver1 operator ver2
#
# **Operators:** [-lt, lesser_than, -gt, greater_than, -eq, equal, -ne, not_equal]
#
# **Returns:** true if comparison statement is correct, else false
##
version_compare() {
	case "$2" in
		# Note: awk is wak... inverse operations so false=non-zero
		lesser_than|-lt) _op='>';;
		lesser_or_equal|-le) _op='<=';;
		greater_than|-gt) _op='<';;
		greater_or_equal|-ge) _op='<=';;
		equal|-eq) _op='!=';;
		not_equal|-ne) _op='==';;
		*) die 'Unknown operatoration called for version_compare().';;
	esac

	# shellcheck disable=SC2086 #[false-positive: nested quotes]
	return "$(awk 'BEGIN {print("'$1'" '$_op' "'$3'")}')"
}

#!/bin/sh
##
# Title:      Script Helpers (sh)
# Copyright:  2020 Michael Lustfield <MTecknology>
# License:    GPL-3+
##


##
# Convenience Variables
##

SCRIPT_HELPER_VERSION='dev'
# Version of this script
readonly SCRIPT_HELPER_VERSION
export SCRIPT_HELPER_VERSION

DEBUG=0; D=0
INFO=1; I=1
WARN=2; W=2
ERROR=3; E=3
# Log Levels
readonly D DEBUG I INFO W WARN E ERROR
export D DEBUG I INFO W WARN E ERROR


##
# Helper Functions
##


##
# Return true if script version is between min/max ('dev' == git_HEAD).
#
# **Usage:** helper_version min [max]
#
# - min => minimum supported version
# - max => maximum supported version
#
# **Returns:** true if script version is between min and [optionally:max]
##
helper_version() {
	# Check minimum version
	if [ "$SCRIPT_HELPER_VERSION" != 'dev' ]; then
		version_compare "$SCRIPT_HELPER_VERSION" 'lesser_than' "$1" && return 1
	fi

	# Check maximum version
	[ "${2:-dev}" = 'dev' ] && return 0
	version_compare "$SCRIPT_HELPER_VERSION" 'greater_than' "$2" && return 1

	return 0
}


##
# Print a formatted (critical) message and exit with status.
#
# **Usage:** die [exit_status] message
#
# - exit_status => exit code to use with script termination (default: 1)
# - message => message to print before terminating script execution
#
# **Defaults:**
#
# - exit_status: 1
##
die() {
        # If first argument was an integer, use as exit_status
        if [ "$1" -eq "$1" ] 2>/dev/null; then
                _exit_status="$1"; shift
        else
                _exit_status=1
        fi

        printf '*** CRITICAL: %s ***\n' "$1"
        exit "$_exit_status"
}


##
# Manage a lock file.
#
# **Usage:** lock operation [key]
#
# - operation => acquire, destroy
# - key => any unique value to identify this script (default: $0)
#
# **Returns:** true if success, else false
##
lock() {
	_h="$(printf '%s' "${2:-$0}" | cksum | awk '{print $1}')"
	case "$1" in
		acquire) _lock_acquire "/tmp/$_h.lock";;
		destroy) rm -f "/tmp/$_h.lock";;
	esac
}

# Create and populate the lock file.
_lock_acquire() {
	# Check if running
	[ -e "$1" ] && kill -0 "$(cat "$1")" && return 1

	# make sure the lockfile is removed when we exit and then claim it
	# shellcheck disable=SC2064 #[is there a better way?]
	trap "rm -f $1; exit" INT TERM EXIT
	echo $$ > "$1"

	return 0
}

##
# Print a formatted (critical) message if ENV[LOG_LEVEL] >= level.
#
# **Usage:** log level message
#
# - level => 0:debug, 1:info, \*2:warn, 3:error
# - message => any string of text to be sent to stdout
#
# **Defaults:**
#
# - ENV[LOG_LEVEL]: 2
#
##
log() {
        if [ "${LOG_LEVEL:-2}" -le "$1" ]; then
                case "$1" in
                        0) lvl='DEBUG';;
                        1) lvl='INFO';;
                        2) lvl='WARN';;
                        3) lvl='ERROR';;
                        *) lvl='UNKNOWN';;
                esac

                printf '*** %s: %s ***\n' "$lvl" "$2"
        fi
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_true str
#
# **Parameter Options:**
#
# - str => any string to test against
#
# **Returns:** '0' if ($str is 0) or (lower($1) == true)
##
is_true() {
        str="$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')"
        [ "$str" -eq '0' ] 2>/dev/null && return 0
        [ "$str" = 'true' ] && return 0

        return 1
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_false str
#
# - str => any string to test against
#
# **Returns:** '0' if ($str is 1) or (lower($1) != true)
##
is_false() {
        is_true "$1" && return 1
        return 0
}


##
# Compare two versions.
#
# **Usage:** version_compare ver1 operator ver2
#
# - operator => [-lt, lesser_than, -gt, greater_than, -eq, equal, -ne, not_equal]
# - var1 & var2 => arbitrary version strings to compare
#
# **Returns:** true if comparison statement is correct, else false
##
version_compare() {
	case "$2" in
		# Note: awk is wak... inverse operations so false=non-zero
		lesser_than|-lt) _op='>';;
		lesser_or_equal|-le) _op='<=';;
		greater_than|-gt) _op='<';;
		greater_or_equal|-ge) _op='<=';;
		equal|-eq) _op='!=';;
		not_equal|-ne) _op='==';;
		*) die '2' 'Unknown operatoration called for version_compare().';;
	esac

	# shellcheck disable=SC2086 #[false-positive: nested quotes]
	return "$(awk 'BEGIN {print("'$1'" '$_op' "'$3'")}')"
}

#!/bin/sh
##
# Title:      Script Helpers (sh)
# Copyright:  2020 Michael Lustfield <MTecknology>
# License:    GPL-3+
##


##
# Convenience Variables
##

# Version of this script
SCRIPT_HELPER_VERSION='dev'
readonly SCRIPT_HELPER_VERSION
export SCRIPT_HELPER_VERSION

# Log Levels
DEBUG=0; D=0
INFO=1; I=1
WARN=2; W=2
ERROR=3; E=3
readonly DEBUG D INFO I WARN W ERROR E
export DEBUG D INFO I WARN W ERROR E


##
# Helper Functions
##


##
# Check if a command exists in ``$PATH``.
#
# **Usage:** command_present bin
#
# - bin: name of command
#
# .. code-block:: sh
#
#    for cmd in 'grep' 'xterm'; do
#        command_present "$cmd" || die "$cmd not found"
#    done
##
command_present() {
	command -v "$1" >/dev/null && return 0
	return 1
}


##
# Run all detection routines.
#
# **Usage:** detect_all
#
# **Returns:** true if all detections succeed
#
# .. code-block:: sh
#
#    detect all || die 'Detections failed'
##
detect_all() {
	_e='0'
	detect_distro || _e='1'
	detect_kernel || _e='1'
	detect_release || _e='1'

	return "$_e"
}


##
# Detect distribution of running system.
#
# **Usage:** detect_distro
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_DISTRO
#
# .. code-block:: sh
#
#    detect_distro || die 'Distro is not supported'
##
detect_distro() {
	if [ -n "$H_KERNEL" ]; then
		_kern="$H_KERNEL"
	else
		_kern="$(to_lower "$(detect_kernel; printf '%s' "$H_KERNEL")")"
	fi

	if command_present 'lsb_release'; then
		_distro_lsb
		[ -n "$H_DISTRO" ] && return 0
	fi;if [ -f '/etc/os-release' ]; then
		_distro_release
		[ -n "$H_DISTRO" ] && return 0
	fi;if command_present 'sw_vers'; then
		_distro_swvers
		[ -n "$H_DISTRO" ] && return 0
	fi;if [ "$_kern" = 'freebsd' ]; then
		_distro_freebsd
		[ -n "$H_DISTRO" ] && return 0
	fi

	return 1
}

# Detect release of Linux systems
_distro_lsb() {
	H_DISTRO="$(to_lower "$(lsb_release --short --id)")"
	export H_DISTRO
}

# Detect release from /etc/*release* file
_distro_release() {
	if command_present 'awk'; then
		H_DISTRO="$(to_lower "$(awk -F '=' '/^ID=/{print $2}' /etc/os-release)")"
		H_DISTRO="$(printf '%s' "$H_DISTRO" | sed 's/"//g')"
		if [ -n "$H_DISTRO" ]; then
			export H_DISTRO
			return 0
		fi
	fi
}

# Detect release of Mac systems
_distro_swvers() {
	H_DISTRO='macos'
	export H_DISTRO
}

# Detect release of FreeBSD systems
_distro_freebsd() {
	H_DISTRO='freebsd'
	export H_DISTRO
}


##
# Detect distribution of running system.
#
# **Usage:** detect_distro
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_DISTRO
#
# .. code-block:: sh
#
#    detect_distro || die 'Distro is not supported'
##
detect_init() {
	if [ -e '/sbin/init' ]; then
		H_INIT="$(to_lower "$(/sbin/init --version | awk '{print $1}')")"
		export H_INIT
		return 0
	fi
	return 1
}


##
# Detect kernel of running system.
#
# **Usage:** detect_kernel
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_KERNEL
#
# .. code-block:: sh
#
#    detect_kernel || die 'Kernel is not supported'
##
detect_kernel() {
	if command_present 'uname'; then
		_kern_uname
		[ -n "$H_KERNEL" ] && return 0
	fi

	return 1
}

# Use uname output to detect kernel.
_kern_uname() {
	H_KERNEL="$(to_lower "$(uname -s)")"
	export H_KERNEL
}


##
# Detect distro release of running system.
#
# **Usage:** detect_release
#
# **Returns:** true if detection succeeds
#
# **Exports:** H_RELEASE
#
# .. code-block:: sh
#
#    detect_release || die 'Release is not supported'
##
detect_release() {
	if command_present 'lsb_release'; then
		_release_lsb
		[ -n "$H_RELEASE" ] && return 0
	fi;if [ -f '/etc/os-release' ]; then
		_release_release
		[ -n "$H_RELEASE" ] && return 0
	fi;if command_present 'sw_vers'; then
		_release_swvers
		[ -n "$H_DISTRO" ] && return 0
	fi;if command_present 'freebsd-version'; then
		_release_freebsd
		[ -n "$H_RELEASE" ] && return 0
	fi

	return 1
}

# Detect release version using lsb_release
_release_lsb() {
	H_RELEASE="$(lsb_release --short --release)"
	export H_RELEASE
}

# Detect release from os-release
_release_release() {
	if command_present 'awk'; then
		H_RELEASE="$(to_lower "$(awk -F '=' '/^VERSION_ID=/{print $2}' /etc/os-release)")"
		H_RELEASE="$(printf '%s' "$H_RELEASE" | sed 's/"//g')"
		if [ -n "$H_RELEASE" ]; then
			export H_RELEASE
			return 0
		fi
	fi
}

# Detect release of Mac systems
_release_swvers() {
	H_RELEASE="$(sw_vers -productVersion)"
	export H_RELEASE
}

# Detect release of FreeBSD system
_release_freebsd() {
	H_RELEASE="$(freebsd-version -k)"
	export H_RELEASE
}


##
# Print a formatted (critical) message and exit with status.
#
# **Usage:** die [exit_status] message
#
# - exit_status: exit code to use with script termination (default: 1)
# - message: message to print before terminating script execution
#
# .. code-block:: sh
#
#    [ -n "$foo" ] || die 255 '$foo not defined'
##
die() {
        # If first argument was an integer, use as exit_status
	case "$1" in
		(*[!0123456789]*) _exit_status=1;;
		(*) _exit_status="$1"; shift;;
	esac

        printf '*** CRITICAL: %s ***\n' "$1"
        exit "$_exit_status"
}


##
# Check if string ends with another string
#
# **Usage:** ends_with key str
#
# - key: string to search for
# - str: ascii string to search
#
# **Returns:** true if str ends with key
#
# .. code-block:: sh
#
#    ends_with 'init' "$input" || die 'invalid input'
#    low="$(to_lower "$up")"
##
ends_with() {
	case "$2" in
		(*"$1") return 0;;
		(*) return 1;;
	esac
}


##
# Return true if script version is between min/max ('dev' == git_HEAD).
#
# **Usage:** helper_version min [max]
#
# - min: minimum supported version
# - max: maximum supported version
#
# **Returns:** true if script version is between min and [optionally:max]
#
# .. code-block:: sh
#
#    helper_version '1.0.0' '1.999' ||
#            die 'Helper version 1.x required!'
##
helper_version() {
	# Check minimum version
	if [ "$SCRIPT_HELPER_VERSION" != 'dev' ]; then
		version_compare "$SCRIPT_HELPER_VERSION" 'lesser_than' "$1" && return 1
	fi

	# Check maximum version
	[ "${2:-dev}" = 'dev' ] && return 0
	[ "$SCRIPT_HELPER_VERSION" = 'dev' ] && return 1
	version_compare "$SCRIPT_HELPER_VERSION" 'greater_than' "$2" && return 1

	return 0
}


##
# Check if a value is present in a string.
#
# **Usage:** in_string needle haystack
#
# - needle: value to search for
# - haystack: string to be searched
#
# **Returns:** true if needle was found
#
# .. code-block:: sh
#
#    in_string 'fuz' 'abcfuz123' && echo 'found some fuz'
##
in_string() {
	expr "_$2" : "_.*$1" >/dev/null && return 0
	return 1
}


##
# Evaluate if running distribution matches provided argument(s).
#
# **Usage:** is_distro match [match..]
#
# - match: any string to test against (Debian, Ubuntu, RHEL, etc.)
#
# **Returns:** true if running distro matches a provided 'match'
#
# .. code-block:: sh
#
#    is_distro 'Debian' || die 'Only Debian is supported'
##
is_distro() {
	if [ -n "$H_DISTRO" ]; then
		_needle="$H_DISTRO"
	else
		_needle="$(detect_distro; printf '%s' "$H_DISTRO")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect distro.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_false str
#
# - str: any string to test against
#
# **Returns:** true if ($str != 0) or (lower($str) != true)
#
# .. code-block:: sh
#
#    is_false 'lies' || die 'I am too gullible'
##
is_false() {
        is_true "$1" && return 1
        return 0
}


##
# Evaluate if running distribution matches provided argument(s).
#
# **Usage:** is_distro match [match..]
#
# - match: any string to test against (Debian, Ubuntu, RHEL, etc.)
#
# **Returns:** true if running distro matches a provided 'match'
#
# .. code-block:: sh
#
#    is_distro 'Debian' || die 'Only Debian is supported'
##
is_init() {
	if [ -n "$H_INIT" ]; then
		_needle="$H_INIT"
	else
		_needle="$(detect_init; printf '%s' "$H_INIT")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect init.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if a given string is a int.
#
# **Usage:** is_int str
#
# - str: any string to test against
#
# **Returns:** true if str is an integer
#
# .. code-block:: sh
#
#    is_int "$foo" || die 'Argument must be an integer.'
##
is_int() {
	case "$1" in
		(*[!0123456789]*) return 1;;
		(*) return 0;;
	esac
}


##
# Evaluate if running kernel matches provided argument(s).
#
# **Usage:** is_kernel match [match..]
#
# - match: any string to test against (Linux, BSD, etc.)
#
# **Returns:** true if running kernel matches a provided 'match'
#
# .. code-block:: sh
#
#    is_kernel 'Linux' 'BSD' || die 'Only Linux/BSD are supported'
##
is_kernel() {
	if [ -n "$H_KERNEL" ]; then
		_needle="$H_KERNEL"
	else
		_needle="$(detect_kernel; printf '%s' "$H_KERNEL")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect kernel.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if running distro release matches provided argument.
#
# **Usage:** is_release match [match..]
#
# - match: any string to test against (12.04, 10.1, etc.)
#
# **Returns:** true if running release matches a provided 'match'
#
# .. code-block:: sh
#
#    is_release '14.04' '16.04' '18.04' '20.04' ||
#            die 'Only non-EOL LTS releases are supported'
##
is_release() {
	if [ -n "$H_RELEASE" ]; then
		_needle="$H_RELEASE"
	else
		_needle="$(detect_release; printf '%s' "$H_RELEASE")"
	fi
	[ -n "$_needle" ] || die 7 'Could not detect release.'
	
	for _hay in "$@"; do
		[ "$_needle" = "$_hay" ] && return 0
	done

        return 1
}


##
# Evaluate if a given string is true-like.
#
# **Usage:** is_true str
#
# - str: any string to test against
#
# **Returns:** true if ($str is 0) or (lower($str) == true)
#
# .. code-block:: sh
#
#    is_true "$foo" || die "\$foo said it isn't so..."
##
is_true() {
        _str="$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')"
        [ "$_str" = 'true' ] && return 0
        [ "$_str" = '' ] && return 1
	is_int "$_str" || return 1
        [ "$_str" -eq '0' ] 2>/dev/null && return 0

        return 1
}

##
# Manage a lock file.
#
# **Usage:** lock operation [key]
#
# - operation: acquire, destroy
# - key: any unique value to identify this script (default: $0)
#
# **Returns:** true if success
#
# .. code-block:: sh
#
#    lock aquire "$0" || die 'Unable to grab lock'
#    [...]
#    lock destroy "$0"
##
lock() {
	_h="$(printf '%s' "${2:-$0}" | cksum | awk '{print $1}')"
	case "$1" in
		(acquire) _lock_acquire "/tmp/$_h.lock";;
		(destroy) rm -f "/tmp/$_h.lock";;
	esac
}

# Create a lock file and populate it with PID.
_lock_acquire() {
	# Check if running
	[ -e "$1" ] && kill -0 "$(cat "$1")" && return 1

	# make sure the lockfile is removed when we exit and then claim it
	# shellcheck disable=SC2064 #[we want this expanding now]
	trap "rm -f '$1'; exit" INT TERM EXIT
	echo $$ > "$1"

	return 0
}


##
# Print a formatted message if ENV[LOG_LEVEL] >= level.
#
# **Usage:** log level message
#
# - level: 0:debug, 1:info, \*2:warn, 3:error
# - message: any string of text to be sent to stdout
#
# **Defaults:**
#
# - ENV[LOG_LEVEL]: 2
#
#
# .. code-block:: sh
#
#    log "$INFO" 'Capturing quantum stabilizer'
#    capture_qs || die 'Capture failed!'
##
log() {
        if [ "${LOG_LEVEL:-2}" -le "$1" ]; then
                case "$1" in
                        (0) _lvl='DEBUG';;
                        (1) _lvl='INFO';;
                        (2) _lvl='WARN';;
                        (3) _lvl='ERROR';;
                        (*) _lvl='UNKNOWN';;
                esac

                printf '*** %s: %s ***\n' "$_lvl" "$2"
        fi
}


##
# Check if string starts with another string
#
# **Usage:** starts_with key str
#
# - key: string to search for
# - str: ascii string to search
#
# **Returns:** true if str starts with key
#
# .. code-block:: sh
#
#    starts_with 'init' "$input" || die 'invalid input'
#    low="$(to_lower "$up")"
##
starts_with() {
	[ "$1" = "$2" ] && return 0
	case "$2" in
		("$1"*) return 0;;
		(*) return 1;;
	esac
}


# Convert string from [:upper:] to [:lower:].
#
# **Usage:** to_lower
#
# - str: any ascii string to convert
#
# **Prints:** string in lower
#
# .. code-block:: sh
#
#    low="$(to_lower "$up")"
##
to_lower() {
        printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}


##
# Convert string from [:lower:] to [:upper:].
#
# **Usage:** to_upper
#
# - str: any ascii string to convert
#
# **Prints:** string in uppercase
#
# .. code-block:: sh
#
#    up="$(to_upper "$low")"
##
to_upper() {
        printf '%s' "$1" | tr '[:lower:]' '[:upper:]'
}


##
# Compare two versions.
#
# **Usage:** version_compare version1 operator version2
#
# - operator:
#
#   + ``-lt``, ``<``, ``lesser_than``
#   + ``-le``, ``<=``, ``lesser_than_or_equal``
#   + ``-gt``, ``>``, ``greater_than``
#   + ``-ge``, ``>=``, ``greater_than_or_equal``
#   + ``-eq``, ``==``, ``equal``
#   + ``-ne``, ``!=``, ``not_equal``
#
# - version{1,2}: arbitrary version strings to compare
#
# **Version Format:** ``[0-9]+($VERSION_SEPARATOR[0-9]+)*`` (i.e. 90, 1.2.3.4)
#
# **Returns:** true if comparison statement is correct
#
# .. code-block:: sh
#
#    version_compare "$_version" '-lt' '1.0' ||
#        die 'Unexpected (pre-release) version found'
##
version_compare() {
	_largest_version "$1" "$3"; _cmp="$?"

	# Check for valid responses or bail early
	case "$_cmp" in
		(1|0|2) :;;     # Expected (valid) resturn values
		(*) die "$_cmp" 'version comparison failed';;
	esac

	# The easy part
	case "$2" in
		('lesser_than'|'-lt'|'<')
			[ "$_cmp" = '2' ] && return 0
			;;
		('lesser_or_equal'|'-le'|'<=')
			[ "$_cmp" = '0' ] && return 0
			[ "$_cmp" = '2' ] && return 0
			;;
		('greater_than'|'-gt'|'>')
			[ "$_cmp" = '1' ] && return 0
			;;
		('greater_or_equal'|'-ge'|'>=')
			[ "$_cmp" = '1' ] && return 0
			[ "$_cmp" = '0' ] && return 0
			;;
		('equal'|'-eq'|'==')
			[ "$_cmp" = '0' ] && return 0
			;;
		('not_equal'|'-ne'|'!=')
			[ "$_cmp" = '1' ] && return 0
			[ "$_cmp" = '2' ] && return 0
			;;
		(*) die 7 'Unknown operatoration called for version_compare().';;
	esac
	return 1
}

##
# Compare two versions.
# Check if one version is larger/smaller/equal than/to another.
#
# **Usage:** _largest_version ver1 ver2
#
# Returns: ($1 > $2): 1 ; ($1 = $2): 0 ; ($1 < $2): 2
# [IOW- 1 = $1 is largest; 0 = neither ; 2 = $2 is largest]
##
_largest_version() (
	# Value used to separate version components
	VERSION_SEPARATOR="${VERSION_SEPARATOR:-.}"

	for _p in "$1" "$2"; do
		[ "$(printf %.1s "$_p")" = "$VERSION_SEPARATOR" ] &&
			die 7 'invalid version pattern provided'
	done

	# Split versions on VER_SEP into int/sub
	_v="$1$2"
	_v1="$1"
	_s1="${1#*"$VERSION_SEPARATOR"}"
	if [ "$_v1" = "$_s1" ]; then
		_s1=''
		_m1="$_v1"
	else
		_m1="${1%%"$VERSION_SEPARATOR"*}"
	fi
	_v2="$2"
	_s2="${2#*"$VERSION_SEPARATOR"}"
	if [ "$_v2" = "$_s2" ]; then
		_s2=''
		_m2="$_v2"
	else
		_m2="${2%%"$VERSION_SEPARATOR"*}"
	fi

	# Both are equal
	[ "$_v1" = "$_v2" ] && return 0

	# Something is larger than nothing (30 < 30.0)
	if [ -n "$_v1" ] && [ ! -n "$_v2" ]; then
		return 1
	elif [ ! -n "$_v1" ] && [ -n "$_v2" ]; then
		return 2
	fi

	# Check for invalid
	is_int "$_m1$_m2" || die 7 'invalid version pattern provided'

	# If a ver_sep is present
	if in_string "$VERSION_SEPARATOR" "$_v"; then
		# Check for a larger "major" version number
		[ "$_m1" -lt "$_m2" ] && return 2
		[ "$_m1" -gt "$_m2" ] && return 1

		# Compare substring components
		_largest_version "$_s1" "$_s2"; return "$?"
	else
		# Only integers present; simple integer comparison
		[ "$_v1" -lt "$_v2" ] && return 2
		[ "$_v1" -gt "$_v2" ] && return 1
	fi
)
